---
title: "Project 2"
author: "Anton Stråhle"
date: "15 februari 2020"
output: pdf_document
---

#Exercise 1

```{r}

library(knitr)
library(readr)
library(tidyverse)

data <- read.delim("Projekt2_Grupp9.txt", sep = ";") %>% 
  mutate(ClaimYear = floor((ClaimDay-1)/365) + 1,
         PaymentYear = floor((PaymentDay-1)/365) + 1) %>% 
  rbind(c(1,1,1,0,1,10)) %>% 
  rbind(c(1,1,1,0,10,19)) #Added to deal with aggregation in a simple manner

t <- data %>% 
  group_by(ClaimYear, PaymentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>% 
  mutate(DevelopmentYear = PaymentYear-ClaimYear + 1) %>% 
  select(-PaymentYear) %>% 
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() 

ct <- t %>% 
  filter(ClaimYear >= 11) %>% 
  select(-ClaimYear) %>% 
  as.matrix()

trap <- t %>%
  select(-ClaimYear) %>% 
  as.matrix()

#Estimates the incremental factors f based on the observed triangle (not trapezoid!)

estimateF <- function(trap, os = 0){
  
  n <- ncol(trap)
  
  r <- nrow(trap)
  
  fVec <- c()
  
  for(i in 1:(n-1)){
    
    f <- sum(trap[1:(r-i+os),i+1])/sum(trap[1:(r-i + os),i]) 
    
    fVec[i] <- f
    
  }
  
  fVec
  
}


fillct <- function(ct, s = 1, trapezoid = trap){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  fHat <- estimateF(trapezoid)
  
  for(i in s:r){
  
    for(j in (n-i+s):n){
    
    ct[i,j] <- ct[i,j-1]*fHat[j-1]
    
    }
    
  }

  ct
  
}


fullct <- fillct(ct)

fHat <- estimateF(trap)

kable(fullct %>% data.frame(), caption = "Full claims triangle predicted with CL", row.names = c(1:10), col.names = c(1:11))
```

#Exercise 2

We now want to check whether or not Mack's undrlying assumptions are met in our case. The assumptions are as follows.

\begin{enumerate}
  \item $E[C_{i,k+1}|C_{i,1},...,C{i,k}] = f_kC_{i,k}$
  \item Independent accident years
  \item $Var(C_{i,k+1}|C_{i,1},...,C{i,k}) = \sigma_k^2C_{i,k}$
\end{enumerate}

We begin by examing whether or not the we have an approximate linear relationship between $C_{i,k}$ and $C_{i,k+1}$ for $i = 1,...,10$

```{r}

#Gör om gör fint!

plot(trap[,1], trap[,2])
lines(seq(5e6,2e7, by = 10000), sapply(X = seq(5e6,2e7, by = 10000), FUN = function(x){ x*fHat[1]}), col = "blue")

plot(trap[,2], trap[,3])
lines(seq(1e7,4e7, by = 10000), sapply(X = seq(1e7,4e7, by = 10000), FUN = function(x){ x*fHat[2]}), col = "blue")

plot(trap[,3], trap[,4])
lines(seq(1e7,5e7, by = 10000), sapply(X = seq(1e7,5e7, by = 10000), FUN = function(x){ x*fHat[3]}), col = "blue")

plot(trap[,4], trap[,5])
lines(seq(1e7,5e7, by = 10000), sapply(X = seq(1e7,5e7, by = 10000), FUN = function(x){ x*fHat[4]}), col = "blue")

plot(trap[,5], trap[,6])
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[5]}), col = "blue")

plot(trap[,6], trap[,7])
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[6]}), col = "blue")

plot(trap[,7], trap[,8])
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[7]}), col = "blue")

plot(trap[,8], trap[,9])
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[8]}), col = "blue")

plot(trap[,9], trap[,10])
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[9]}), col = "blue")

plot(trap[,10], trap[,11])
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[10]}), col = "blue")
#Skoja dem blev faktiskt inte så fula

```

We note that the linear approximation seems to hold. We now want to plot the weighted residuals.

```{r}

residualHelper <- function(s = 11, trapezoid = trap){
  
  fHat <- estimateF(trapezoid)
  
  n <- ncol(trapezoid)
  
  r <- nrow(trapezoid)
  
  df <- data.frame(matrix(ncol = 3, nrow = 0))
  
  for(i in 1:(r-1)){
    
    for(j in 2:min(n+s-i-1, n)){
    
      res <- (trapezoid[i,j] - trapezoid[i,j-1]*fHat[j-1])/sqrt(trapezoid[i,j-1])
      
      df <- rbind(df, c(i,unname(res), trapezoid[i,j-1]))
    
    }
    
  }

  df
  
}

resFrame <- residualHelper() %>% 
  setNames(c("Year", "Res", "Ci"))

ggplot(resFrame, aes(x = Ci, y = Res)) +
  geom_point() +
  facet_wrap(~Year, scales = "free_y") 

#Plottar alla år då vi anväder trapezoiden för att skatta f och sigma

#Notera att vi bara beaktar år med fler än 6 punkter enl Mack!

```

All years with more than 6 points, as suggested by Mack, seem to showcase random behaviour and no signs of any systematic deviations.

Lastly we want to examine whether or not we have any calender year effects. An example of a scenario where the assumption of independent years might be violated is if there is an overhaul of the way claims are handled.

```{r}

#Alltså detta är så dumt

n <- ncol(trap)

r <- nrow(trap)

fList <- list()

for(k in 1:(n-1)){
  
  fk <- c()
  
  for(i in 1:(r-k+1)){
    
    temp <- trap[i, k+1]/trap[i,k]
    
    names(temp) <- k+i-1 #år
    
    fk <- c(fk, temp)
    
  }
  
  fList[[k]] <- sort(fk)
  
}

fList

#Detta blev ju väldigt fult men det får fram budskapet
#Gör en tabell där man räknar kardinaleteten av
#sFk och lFk för alla k

#Detta blev ju väldigt fult men det får fram budskapet
#Gör en tabell där man räknar kardinaleteten av
#sFk och lFk för alla k


```

We might have some seasonal dependence idk??

#Exercise 3

From the paper by Mack we have that 

$$
Var(C_{i,I}) = C_{i,I}^2 \sum_{k=I+1-i}^{I-1} \frac{\sigma_k^2}{f_k^2}\left(\frac{1}{C_{i,k}} + \frac{1}{\sum_{j=1}^{I-k}C_{j,k}}\right)
$$
where we estimate $\sigma_k^2$ by

$$
\hat \sigma_k^2 = \frac{1}{I-k-1}\sum_{j=1}^{I-k}C_{j,k}\left(\frac{C_{j,k+1}}{C_{j,k}-\hat f_k}\right)^2
$$
which is an unbiased estimator. 

```{r}

#WE now need the last 11 years
#För att estimera sigma10 behöver vi de senaste 12 inte 11!!

ct11 <- data %>% filter(ClaimYear >= 10) %>% 
  group_by(ClaimYear, PaymentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>% 
  mutate(DevelopmentYear = PaymentYear-ClaimYear + 1) %>% 
  select(-PaymentYear) %>% 
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  select(-ClaimYear) %>% 
  as.matrix()


estimateSigma <- function(s, trapezoid = trap){
  
  n <- ncol(trapezoid)
  
  C <- fillct(trapezoid, s, trapezoid)
  
  fHat <- estimateF(trapezoid)
  
  sigmaHat <- c()
  
  for(k in 1:(n-2)){
    
    sum <- 0
    
    for(j in 1:(n-k)){
      
      sum = sum + C[j,k]*(C[j,k+1]/(C[j,k]) - fHat[k])^2 
      
    }
    
    sigmaHat = c(sigmaHat, unlist(sum/(n-k-1)))
    
  }
  
  last <- min(sigmaHat[n-2]^2/sigmaHat[n-3], min(sigmaHat[n-2], sigmaHat[n-3]))
  
  names(last) <- n-1
  
  c(sigmaHat, last)
  
}

sigmaHat <- estimateSigma(11) #estimates sigma^2


riskCalculation <- function(ct, adj = 2, trapezoid = trap){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  C <- fillct(ct, s = adj, trapezoid = trapezoid)
  
  fHat <- estimateF(trapezoid)
  
  sigmaHat <- estimateSigma(nrow(trapezoid)-n+adj) #estimates sigma^2
  
  risks <- c()
  
  for(i in adj:r){
    
    sum <- 0
    
    for(k in (n+1-i):(n-1)){
      
      sum = sum + sigmaHat[k]/fHat[k]^2*(1/C[i,k] + 1/sum(C[1:(n-k),k])) 
      
    }
   
    risks <- c(risks, sum*C[i,n]^2)
     
  }
 
  risks
  
}

risks <- cbind(1:10,riskCalculation(ct11), fullct[1:10,10]) %>% 
  data.frame() %>% 
  setNames(c("Year", "Reserve Risk", "Reserve")) 

kable(risks, caption = "Reserve risk for coming years")

```


```{r}

prevct <- trap[1:10,]

estimateFAlt <- function(ct, known = 0){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  fVec <- c()
  
  for(i in 1:(n-1)){
    
    f <- sum(ct[1:min(r-i+known, r),i+1])/sum(ct[1:min(r-i+known, r),i])
    
    fVec[i] <- f
    
  }
  
  fVec
  
}


fillAlt <- function(ct, known = 0){
  
  temp <- ct
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  fHat <- estimateFAlt(ct, known)
  
  if(known < r){
  
    for(i in (known+1):r){
    
      for(j in (n-i+known+1):n){
        
        temp[i,j] <- temp[i,j-1]*fHat[j-1]
      
      }
      
    }

  }
  
  temp
  
  
}

uc <- c()

for(i in 0:10){
  
  val <- sum(fillAlt(prevct, i)[,11])
  
  uc <- c(uc, val)
  
}

kable(uc, caption = "Ultimate claim amounts over observed years", col.names = "UCA", row.names = seq(0,10,1))

```

Looks pretty good to me.

#Exercise 4

```{r}

#need incremental data

truect <- fillct(ct11, 2)

trueincct <- truect[,1:11] - cbind(rep(0,10),truect[,1:10])

altFHats <- estimateFAlt(trueincct, 10)

#Oklart hur vi ska göra, frågar senare

```




