---
title: "Project 2"
author: "Anton Stråhle"
date: "15 februari 2020"
output: pdf_document
---

#Exercise 1

```{r, echo = FALSE, warning = FALSE}

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(readr))
suppressPackageStartupMessages(library(kableExtra))
suppressPackageStartupMessages(library(gridExtra))

options(knitr.kable.NA = '')

data <- read.delim("Projekt2_Grupp9.txt", sep = ";") %>% 
  mutate(ClaimYear = floor((ClaimDay-1)/365) + 1,
         PaymentYear = floor((PaymentDay-1)/365) + 1) %>% 
  mutate(DevelopmentYear = PaymentYear-ClaimYear + 1) %>% 
  select(-PaymentYear) %>% 
  complete(ClaimType, nesting(ClaimYear, DevelopmentYear), fill = list(PaymentDay = 1, ClaimCost = 0, ClaimDay = 0)) %>% 
  filter(DevelopmentYear < 11)
  

ct1 <- data %>% 
  filter(ClaimType == 1) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>%
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  filter(ClaimYear >= 11) %>% 
  select(-ClaimYear)

ct2 <- data %>% 
  filter(ClaimType == 2) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>%
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  filter(ClaimYear >= 11) %>% 
  select(-ClaimYear)

#Estimates the incremental factors f based on the observed triangle (not trapezoid!)

estimateF <- function(ct){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  fVec <- c()
  
  for(i in 1:(n-1)){
    
    f <- sum(ct[1:(r-i),i+1])/sum(ct[1:(r-i),i])
    
    fVec[i] <- f
    
  }
  
  fVec
  
}


fillct <- function(ct){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  s <- r - n
  
  fHat <- estimateF(ct)
  
  for(i in (2+s):r){
  
    for(j in (n-i+2+s):n){
    
      ct[i,j] <- ct[i,j-1]*fHat[j-1]
    
    }
    
  }

    ct
  
}

fHat1 <- estimateF(ct1)

fHat2 <- estimateF(ct2)

fullct1 <- fillct(ct1)

fullct2 <- fillct(ct2)

```

The purpose of this project is to examine how one can predict future expenses in order to be able to reserve against them. Specifically we wish to examine both the expected future payments as well as the variance within these payments. The data which we have been given is collected over several years and divided between two vastly different insurance products, henceforth refered to as product, or branch, 1 or 2. The final 10 years of the data can be aggregated in order to create the following two paid claims triangles. Lastly, since the claims triangle is limited to 10 development years the data has been truncated to accomodate this limit.

`r kable(ct1, caption = "Paid claims triangle for product 1", row.names = c(1:10)) %>% kable_styling(latex_options =c("hold_position", "scale_down"))`

`r kable(ct2, caption = "Paid claims triangle of product 2", row.names = c(1:10)) %>% kable_styling(latex_options =c("hold_position", "scale_down"))`

Using Mack's non-parametric CL approach we can predict the total cost of future payments per year as follows.

`r kable(fullct1, caption = "Full claims triangle of type 1 predicted with CL", row.names = c(1:10)) %>% kable_styling(latex_options =c("hold_position", "scale_down"))`

`r kable(fullct2, caption = "Full claims triangle of type 2 predicted with CL", row.names = c(1:10)) %>% kable_styling(latex_options =c("hold_position", "scale_down"))`

\newpage

Lastly we wish to predict the future payments for each of the claims years, i.e. those on the vertical axes, and then combine them into a the total chain ladder reserve.

```{r echo = FALSE, warning = FALSE}

reserve1 <- as.matrix(fullct1)[, 10] - diag(as.matrix(fullct1)[10:1,])[10:1]

reserve2 <- as.matrix(fullct2)[, 10] - diag(as.matrix(fullct2)[10:1,])[10:1]

kable(rbind(c("Product 1" , sum(reserve1)), c("Product 2", sum(reserve2))), digits = 2, caption = "Chain Ladder Reserve") %>%  kable_styling(latex_options =c("hold_position"))

```


#Exercise 2

We now want to check whether or not Mack's underlying assumptions are met in our case. The assumptions are as follows.

\begin{enumerate}
  \item $E[C_{i,k+1}|C_{i,1},...,C{i,k}] = f_kC_{i,k}$
  \item Independent accident years
  \item $Var(C_{i,k+1}|C_{i,1},...,C{i,k}) = \sigma_k^2C_{i,k}$
\end{enumerate}

We begin by examing whether or not the we have an approximate linear relationship between $C_{i,k}$ and $C_{i,k+1}$ for $i = 1,...,10$.

```{r echo = FALSE, warning = FALSE}

#Gör om gör fint!

par(mfrow=c(4,2), cex=0.35) 

plot(ct1$`1`, ct1$`2`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[1]}), col = "blue")

plot(ct1$`2`, ct1$`3`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[2]}), col = "blue")

plot(ct1$`3`, ct1$`4`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[3]}), col = "blue")

plot(ct1$`4`, ct1$`5`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[4]}), col = "blue")

plot(ct1$`5`, ct1$`6`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[5]}), col = "blue")

plot(ct1$`6`, ct1$`7`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[6]}), col = "blue")

plot(ct1$`7`, ct1$`8`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[7]}), col = "blue")

plot(ct1$`8`, ct1$`9`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[8]}), col = "blue")

#Skoja dem blev faktiskt inte så fula men fixa axlarna

par(mfrow=c(4,2), cex=0.35) 

plot(ct2$`1`, ct2$`2`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[1]}), col = "blue")

plot(ct2$`2`, ct2$`3`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[2]}), col = "blue")

plot(ct2$`3`, ct2$`4`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[3]}), col = "blue")

plot(ct2$`4`, ct2$`5`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[4]}), col = "blue")

plot(ct2$`5`, ct2$`6`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[5]}), col = "blue")

plot(ct2$`6`, ct2$`7`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[6]}), col = "blue")

plot(ct2$`7`, ct2$`8`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[7]}), col = "blue")

plot(ct2$`8`, ct2$`9`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[8]}), col = "blue")

```

We note that the linear approximation seems to hold. Secondly we wish to examine the weighted residuals $\frac{C_{i,k+1}-C_{i,k}f_k}{C_{i,k}}$ in order to see if we have randomness, i.e. no systematic behaviours within the years.  

```{r echo = FALSE, warning = FALSE}

residualHelper <- function(ct){
  
  fHat <- estimateF(ct)
  
  n <- nrow(ct)
  
  df <- data.frame(matrix(ncol = 3, nrow = 0))
  
  for(i in 1:(n-1)){
  
    for(j in 2:(n-i+1)){
    
      res <- (ct[i,j] - ct[i,j-1]*fHat[j-1])/sqrt(ct[i,j-1])
      
      df <- rbind(df, unlist(c(i,unname(res), ct[i,j-1])))
    
    }
    
  }

  df
  
}


resFrame1 <- residualHelper(ct1) %>% 
  setNames(c("Year", "Res", "Ci"))

res1 <- ggplot(resFrame1, aes(x = Ci, y = Res)) +
  geom_point() +
  facet_wrap(~Year, scales = "free_y") 

#Notera att vi bara beaktar år med fler än 6 punkter enl Mack!
#OBS enbart använt vanliga f. Kan vara bra att kolla resterande

resFrame2 <- residualHelper(ct2) %>% 
  setNames(c("Year", "Res", "Ci"))

res2 <- ggplot(resFrame2, aes(x = Ci, y = Res)) +
  geom_point() +
  facet_wrap(~Year, scales = "free_y")

#FIXA SNYGGT!!

grid.arrange(res1, res2)

```

All years with more than 6 points, the threshold suggested by Mack, seem to showcase random behaviour and no clear signs of any systematic deviations. 

Lastly we want to examine whether or not we have any calender year effects. An example of a scenario where the assumption of independent years might be violated is if there is an overhaul of the way claims are handled which comes into effect during a specific year.

```{r echo = FALSE, warning = FALSE}

#Branch 1

n <- nrow(ct1)

fList1 <- list()

for(k in 1:(n-1)){
  
  fk <- c()
  
  for(i in 1:(n-k)){
    
    temp <- unlist(ct1[i, k+1])/unlist(ct1[i,k])
    
    names(temp) <- k+i-1 #år
    
    fk <- c(fk, temp)
    
  }
  
  fList1[[k]] <- sort(fk)
  
  
  
}

fList1

#Branch 2

n <- nrow(ct2)

fList2 <- list()

for(k in 1:(n-1)){
  
  fk <- c()
  
  for(i in 1:(n-k)){
    
    temp <- unlist(ct2[i, k+1])/unlist(ct2[i,k])
    
    names(temp) <- k+i-1 #år
    
    fk <- c(fk, temp)
    
  }
  
  fList2[[k]] <- sort(fk)
  
}

fList2


#Detta blev ju väldigt fult men det får fram budskapet
#Gör en tabell där man räknar kardinaleteten av
#sFk och lFk för alla k??


```

From the previous figures it looks as if we might have some annual dependencies, they are however not significant enough to make us deviate from the use of Mack's non-parametric CL.

#Exercise 3
In this exercise we wish to examine the variance parameter for the last development year (i.e. development year 10). We can do this by implementing the formulas presented in Mack's paper. First we have that

$$
\widehat{\text{s.e.}}(R)^2 = \sum_{i=2}^{I} \widehat{\text{s.e.}}(C_{i,I})^2 + C_{i,I}\left(\sum_{j=i+1}^I C_{j,I}\right)\sum_{k=I+1-i}^{I-1}\frac{2\hat\sigma_k^2}{\hat f_k^2\sum_{n=1}^{I-k}C_{n,k}}
$$

where

$$
\widehat{\text{s.e.}}(C_{i,I})^2 = C_{i,I}^2 \sum_{k=I+1-i}^{I-1} \frac{\hat\sigma_k^2}{\hat f_k^2}\left(\frac{1}{C_{i,k}} + \frac{1}{\sum_{j=1}^{I-k}C_{j,k}}\right)
$$

and where we estimate $\sigma_k^2$ by

$$
\hat \sigma_k^2 = \frac{1}{I-k-1}\sum_{j=1}^{I-k}C_{j,k}\left(\frac{C_{j,k+1}}{C_{j,k}-\hat f_k}\right)^2
$$
and

$$
\hat f_k = \frac{\sum_{j=1}^{I-k}C_{i,k+1}}{\sum_{j=1}^{I-k}C_{i,k}}
$$
as previously.

```{r echo = FALSE, warning = FALSE}

#WE now need the last 11 years

ct1Alt <- data %>% 
  rbind(c(1,10,10,1,1,0)) %>% 
  filter(ClaimType == 1) %>% 
  filter(ClaimYear >= 10) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>% 
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  select(-ClaimYear)

ct2Alt <- data %>% 
  rbind(c(2,10,10,1,1,0)) %>% 
  filter(ClaimType == 2) %>% 
  filter(ClaimYear >= 10) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>% 
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  select(-ClaimYear)

estimateSigma <- function(ct){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  C <- fillct(ct)
  
  fHat <- estimateF(ct)
  
  sigmaHat <- c()
  
  for(k in 1:(n-1)){
    
    sum <- 0
    
    for(i in 1:(r-k)){
      
      sum = sum + C[i,k]*(C[i,k+1]/(C[i,k]) - fHat[k])^2 
      
    }
    
    sigmaHat = c(sigmaHat, unlist(sum)/(n-k-0)) #-0 då i_0 = 0
    
  }
  
  sigmaHat
  
}

sigmaHat1 <- estimateSigma(ct1Alt) #estimates sigma^2 for type 1

sigmaHat2 <- estimateSigma(ct2Alt) #estimates sigma^2 for type 2

riskCalculation <- function(ct, ctAlt){
  
  n <- ncol(ct)
  
  C <- matrix(unlist(fillct(ct)), ncol = n)
  
  fHat <- estimateF(ctAlt)
  
  sigmaHat <- estimateSigma(ctAlt) #estimates sigma^2
  
  sum <- 0
  
  for(i in 2:n){
    
    for(k in (n+1-i):(n-1)){
      
      sum = sum + C[i,n]^2*(sigmaHat[k]/fHat[k]^2*(1/C[i,k] + 1/sum(C[1:(n-k),k]))) 
      
    }
    
    if(i < n){
      
      extra = C[i,n]*sum(C[(i+1):n,n])*2*sum((sigmaHat/fHat^2)[(n+1-i):(n-1)])/sum(C[1:(n-k), k])
      
    } else {
      
      extra = 0
      
    }
    
    sum = sum + extra
    
  }
 
  sum
  
}

risk1 <- unname(riskCalculation(ct1, ct1Alt))

risk2 <- unname(riskCalculation(ct2, ct2Alt))

kable(rbind(c("Product 1", risk1), c("Product 2", risk2)), caption = "Reserve Risk") %>%  kable_styling(latex_options =c("hold_position"))

```

We see that there is vastly more risk in Product 2 than Product 1 which seems understandable if we note that there seems to be no new claims during the last six four development years, meaning that the risk only propogates in the initial 6 development years, at least according to our observed years. Another factor that leads to this difference is the fact that the ultimate claims reserve is greater for the first insurance product compared to the second.

#Exercise 4

In this exercise we aim to predict the ultimate claim amounts $R_1$ and $R_2$ for insurance product 1 and 2 respectiveley. We then want to update our predictions assuming that we access to more data. In this case we use the first 10 years of data which have been fully developed whilst assuming that we only have access to a fraction of those years. Initially we assume to know the outcomes of the first 5 years which can be presented in the following claims triangles.

```{r echo = FALSE, warning = FALSE}


disp1 <- data %>% 
  rbind(c(1,1,10,1,1,0)) %>% 
  rbind(c(1,10,10,1,1,0)) %>% 
  filter(ClaimType == 1) %>% 
  filter(ClaimYear + DevelopmentYear <= 11) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>%
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  filter(ClaimYear <= 10) %>% 
  select(-ClaimYear)

disp2 <- data %>% 
  rbind(c(2,1,10,1,1,0)) %>% 
  rbind(c(2,10,10,1,1,0)) %>% 
  filter(ClaimType == 2) %>% 
  filter(ClaimYear + DevelopmentYear <= 11) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>%
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  filter(ClaimYear <= 10) %>% 
  select(-ClaimYear)


kable(disp1, caption = "Paid claims triangle for product 1", row.names = c(1:10)) %>%
  kable_styling(latex_options=c("hold_position", "scale_down"))

kable(disp2, caption = "Paid claims triangle for product 2", row.names = c(1:10)) %>%
  kable_styling(latex_options=c("hold_position", "scale_down"))

```

We then add additional years of data and recalculate the predictions which gives us the following table.  

```{r echo = FALSE, warning = FALSE}

prevct1 <- data %>% 
  rbind(c(1,1,10,1,1,0)) %>% 
  rbind(c(1,10,10,1,1,0)) %>% 
  filter(ClaimType == 1) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>%
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  filter(ClaimYear <= 10) %>% 
  select(-ClaimYear)

prevct2 <- data %>% 
  rbind(c(2,1,10,1,1,0)) %>% 
  rbind(c(2,10,10,1,1,0)) %>% 
  filter(ClaimType == 2) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>%
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  filter(ClaimYear <= 10) %>% 
  select(-ClaimYear)

estimateFAlt <- function(ct, known = 0){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  fVec <- c()
  
  for(i in 1:(n-1)){
    
    f <- sum(ct[1:min(r-i+known, r),i+1])/sum(ct[1:min(r-i+known, r),i])
    
    fVec[i] <- f
    
  }
  
  fVec
  
}


fillAlt <- function(ct, known = 0){
  
  temp <- ct
  
  n <- ncol(ct)
  
  fHat <- estimateFAlt(ct, known)
  
  if(known < (n-1)){
  
    for(i in (known+2):n){
    
      for(j in (n-i+known+2):n){
        
        temp[i,j] <- temp[i,j-1]*fHat[j-1]
      
      }
      
    }

  }
  
  temp
  
}

#Branch 1
# 
# uc1 <- c()
# 
# for(i in 0:8){
#   
#   obs <- as.matrix(fillAlt(prevct1, i))
#   
#   d <- row(obs)-col(obs)
# 
#   diags <- split(obs[10:1,], d)[10:19]
#   
#   uc1 <- c(uc1, sum(obs[(i+1):10,10] - unlist(diags[i+1])))
#   
# }
# 
# 
# uc2 <- c()
# 
# for(i in 0:8){
#   
#   obs <- as.matrix(fillAlt(prevct2, i))
#   
#   d <- row(obs)-col(obs)
# 
#   diags <- split(obs[10:1,], d)[10:19]
#   
#   uc2 <- c(uc2, sum(obs[(i+1):10,10] - unlist(diags[i+1])))
#   
# }


uc2 <- c()

for(i in 0:8){

  obs <- as.matrix(fillAlt(prevct2, i))

  uc2 <- c(uc2, sum(obs[,10]))

}

uc1 <- c()

for(i in 0:8){

  obs <- as.matrix(fillAlt(prevct1, i))

  uc1 <- c(uc1, sum(obs[,10]))

}

cbind(rep(1,9),c(0:8),uc1) %>% 
  rbind(cbind(rep(2,9),c(0:8),uc2)) %>% 
  data.frame() %>% 
  setNames(c("Branch", "Year", "Reserve")) %>%
  spread(value = Reserve, key = Year) %>% 
  kable(caption = "Development of ultimate claims predictions given additional years of data") %>%
  kable_styling(latex_options=c("hold_position", "scale_down"))

```

The main thing to take away from this is that the initial predictions seem to be, in persepctive, quite good predictors of the ultimate claim amounts.

#Exercise 5

```{r echo = FALSE, warning = FALSE}

```


