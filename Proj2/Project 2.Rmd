---
title: "Project 2"
author: "Anton Stråhle"
date: "15 februari 2020"
output: pdf_document
---

#Exercise 1

```{r}

library(knitr)
library(readr)
library(tidyverse)

options(knitr.kable.NA = '')

data <- read.delim("Projekt2_Grupp9.txt", sep = ";") %>% 
  mutate(ClaimYear = floor((ClaimDay-1)/365) + 1,
         PaymentYear = floor((PaymentDay-1)/365) + 1) %>% 
  mutate(DevelopmentYear = PaymentYear-ClaimYear + 1) %>% 
  select(-PaymentYear) %>% 
  complete(ClaimType, nesting(ClaimYear, DevelopmentYear), fill = list(PaymentDay = 1, ClaimCost = 0, ClaimDay = 0)) %>% 
  filter(DevelopmentYear < 11)
  

ct1 <- data %>% 
  filter(ClaimType == 1) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>%
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  filter(ClaimYear >= 11) %>% 
  select(-ClaimYear)

ct2 <- data %>% 
  filter(ClaimType == 2) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>%
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  filter(ClaimYear >= 11) %>% 
  select(-ClaimYear)

#Estimates the incremental factors f based on the observed triangle (not trapezoid!)

estimateF <- function(ct){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  fVec <- c()
  
  for(i in 1:(n-1)){
    
    f <- sum(ct[1:(r-i),i+1])/sum(ct[1:(r-i),i])
    
    fVec[i] <- f
    
  }
  
  fVec
  
}


fillct <- function(ct){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  s <- r - n
  
  fHat <- estimateF(ct)
  
  for(i in (2+s):r){
  
    for(j in (n-i+2+s):n){
    
      ct[i,j] <- ct[i,j-1]*fHat[j-1]
    
    }
    
  }

    ct
  
}

fHat1 <- estimateF(ct1)

fHat2 <- estimateF(ct2)

fullct1 <- fillct(ct1)

fullct2 <- fillct(ct2)

kable(ct1, caption = "Paid claims triangle of type 1", row.names = c(1:10))

kable(ct2, caption = "Paid claims triangle of type 2", row.names = c(1:10))

kable(fullct1, caption = "Full claims triangle of type 1 predicted with CL", row.names = c(1:10))

kable(fullct2, caption = "Full claims triangle of type 2 predicted with CL", row.names = c(1:10))

```

#Exercise 2

We now want to check whether or not Mack's undrlying assumptions are met in our case. The assumptions are as follows.

\begin{enumerate}
  \item $E[C_{i,k+1}|C_{i,1},...,C{i,k}] = f_kC_{i,k}$
  \item Independent accident years
  \item $Var(C_{i,k+1}|C_{i,1},...,C{i,k}) = \sigma_k^2C_{i,k}$
\end{enumerate}

We begin by examing whether or not the we have an approximate linear relationship between $C_{i,k}$ and $C_{i,k+1}$ for $i = 1,...,10$

```{r}

#Gör om gör fint!

plot(ct1$`1`, ct1$`2`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[1]}), col = "blue")

plot(ct1$`2`, ct1$`3`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[2]}), col = "blue")

plot(ct1$`3`, ct1$`4`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[3]}), col = "blue")

plot(ct1$`4`, ct1$`5`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[4]}), col = "blue")

plot(ct1$`5`, ct1$`6`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[5]}), col = "blue")

plot(ct1$`6`, ct1$`7`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[6]}), col = "blue")

plot(ct1$`7`, ct1$`8`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[7]}), col = "blue")

plot(ct1$`8`, ct1$`9`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat1[8]}), col = "blue")

#Skoja dem blev faktiskt inte så fula

plot(ct2$`1`, ct2$`2`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[1]}), col = "blue")

plot(ct2$`2`, ct2$`3`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[2]}), col = "blue")

plot(ct2$`3`, ct2$`4`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[3]}), col = "blue")

plot(ct2$`4`, ct2$`5`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[4]}), col = "blue")

plot(ct2$`5`, ct2$`6`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[5]}), col = "blue")

plot(ct2$`6`, ct2$`7`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[6]}), col = "blue")

plot(ct2$`7`, ct2$`8`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[7]}), col = "blue")

plot(ct2$`8`, ct2$`9`)
lines(seq(1e6,7e7, by = 10000), sapply(X = seq(1e6,7e7, by = 10000), FUN = function(x){ x*fHat2[8]}), col = "blue")

```

We note that the linear approximation seems to hold. We now want to plot the weighted residuals.

```{r}

residualHelper <- function(ct){
  
  fHat <- estimateF(ct)
  
  n <- nrow(ct)
  
  df <- data.frame(matrix(ncol = 3, nrow = 0))
  
  for(i in 1:(n-1)){
  
    for(j in 2:(n-i+1)){
    
      res <- (ct[i,j] - ct[i,j-1]*fHat[j-1])/sqrt(ct[i,j-1])
      
      df <- rbind(df, unlist(c(i,unname(res), ct[i,j-1])))
    
    }
    
  }

  df
  
}

resFrame <- residualHelper(ct1) %>% 
  setNames(c("Year", "Res", "Ci"))

ggplot(resFrame, aes(x = Ci, y = Res)) +
  geom_point() +
  facet_wrap(~Year, scales = "free_y") 

#Notera att vi bara beaktar år med fler än 6 punkter enl Mack!
#OBS enbart använt vanliga f. Kan vara bra att kolla resterande

resFrame <- residualHelper(ct2) %>% 
  setNames(c("Year", "Res", "Ci"))

ggplot(resFrame, aes(x = Ci, y = Res)) +
  geom_point() +
  facet_wrap(~Year, scales = "free_y")

```

All years with more than 6 points, as suggested by Mack, seem to showcase random behaviour and no signs of any systematic deviations.

Lastly we want to examine whether or not we have any calender year effects. An example of a scenario where the assumption of independent years might be violated is if there is an overhaul of the way claims are handled.

```{r}

#Branch 1

n <- nrow(ct1)

fList1 <- list()

for(k in 1:(n-1)){
  
  fk <- c()
  
  for(i in 1:(n-k)){
    
    temp <- unlist(ct1[i, k+1])/unlist(ct1[i,k])
    
    names(temp) <- k+i-1 #år
    
    fk <- c(fk, temp)
    
  }
  
  fList1[[k]] <- sort(fk)
  
}

fList1

#Branch 2

n <- nrow(ct2)

fList2 <- list()

for(k in 1:(n-1)){
  
  fk <- c()
  
  for(i in 1:(n-k)){
    
    temp <- unlist(ct2[i, k+1])/unlist(ct2[i,k])
    
    names(temp) <- k+i-1 #år
    
    fk <- c(fk, temp)
    
  }
  
  fList2[[k]] <- sort(fk)
  
}

fList2


#Detta blev ju väldigt fult men det får fram budskapet
#Gör en tabell där man räknar kardinaleteten av
#sFk och lFk för alla k


```

We might have some seasonal dependence idk??

#Exercise 3

From the paper by Mack we have that 

$$
Var(C_{i,I}) = C_{i,I}^2 \sum_{k=I+1-i}^{I-1} \frac{\sigma_k^2}{f_k^2}\left(\frac{1}{C_{i,k}} + \frac{1}{\sum_{j=1}^{I-k}C_{j,k}}\right)
$$
where we estimate $\sigma_k^2$ by

$$
\hat \sigma_k^2 = \frac{1}{I-k-1}\sum_{j=1}^{I-k}C_{j,k}\left(\frac{C_{j,k+1}}{C_{j,k}-\hat f_k}\right)^2
$$
which is an unbiased estimator. 

```{r}

#WE now need the last 11 years

ct1Alt <- data %>% 
  rbind(c(1,10,10,1,1,0)) %>% 
  filter(ClaimType == 1) %>% 
  filter(ClaimYear >= 10) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>% 
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  select(-ClaimYear)

ct2Alt <- data %>% 
  rbind(c(2,10,10,1,1,0)) %>% 
  filter(ClaimType == 2) %>% 
  filter(ClaimYear >= 10) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>% 
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  select(-ClaimYear)

estimateSigma <- function(ct){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  C <- fillct(ct)
  
  fHat <- estimateF(ct)
  
  sigmaHat <- c()
  
  for(k in 1:(n-1)){
    
    sum <- 0
    
    for(i in 1:(r-k)){
      
      sum = sum + C[i,k]*(C[i,k+1]/(C[i,k]) - fHat[k])^2 
      
    }
    
    sigmaHat = c(sigmaHat, unlist(sum)/(r-k-1)) #Henning sa att I = r (då I = n ger delning med 0)
    
  }
  
  sigmaHat
  
}

sigmaHat1 <- estimateSigma(ct1Alt) #estimates sigma^2 for type 1

sigmaHat2 <- estimateSigma(ct2Alt) #estimates sigma^2 for type 2

riskCalculation <- function(ct, ctAlt){
  
  n <- nrow(ct)
  
  C <- fillct(ct)
  
  fHat <- estimateF(ctAlt)
  
  sigmaHat <- estimateSigma(ctAlt) #estimates sigma^2
  
  risks <- c()
  
  for(i in 2:n){
    
    sum <- 0
    
    for(k in (n+1-i):(n-1)){
      
      sum = sum + sigmaHat[k]/fHat[k]^2*(1/C[i,k] + 1/sum(C[1:(n-k),k])) 
      
    }
   
    risks <- c(risks, unlist(sum*C[i,n]^2))
     
  }
 
  risks
  
}

risks1 <- cbind(2:10,unname(riskCalculation(ct1, ct1Alt)), fullct1[2:10,10]) %>% 
  data.frame() %>% 
  setNames(c("Year", "Reserve Risk", "Reserve")) 

kable(risks1, caption = "Reserve risk for coming years for branch 1")

risks2 <- cbind(2:10,unname(riskCalculation(ct2, ct2Alt)), fullct2[2:10,10]) %>% 
  data.frame() %>% 
  setNames(c("Year", "Reserve Risk", "Reserve")) 

kable(risks2, caption = "Reserve risk for coming years for branch 1")

```



```{r}

prevct1 <- data %>% 
  rbind(c(1,1,10,1,1,0)) %>% 
  rbind(c(1,10,10,1,1,0)) %>% 
  filter(ClaimType == 1) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>%
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  filter(ClaimYear <= 10) %>% 
  select(-ClaimYear)

prevct2 <- data %>% 
  rbind(c(2,1,10,1,1,0)) %>% 
  rbind(c(2,10,10,1,1,0)) %>% 
  filter(ClaimType == 2) %>% 
  group_by(ClaimYear, DevelopmentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>%
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  filter(ClaimYear <= 10) %>% 
  select(-ClaimYear)

estimateFAlt <- function(ct, known = 0){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  fVec <- c()
  
  for(i in 1:(n-1)){
    
    f <- sum(ct[1:min(r-i+known, r),i+1])/sum(ct[1:min(r-i+known, r),i])
    
    fVec[i] <- f
    
  }
  
  fVec
  
}


fillAlt <- function(ct, known = 0){
  
  temp <- ct
  
  n <- ncol(ct)
  
  fHat <- estimateFAlt(ct, known)
  
  if(known < (n-1)){
  
    for(i in (known+2):n){
    
      for(j in (n-i+known+2):n){
        
        temp[i,j] <- temp[i,j-1]*fHat[j-1]
      
      }
      
    }

  }
  
  temp
  
}

#Branch 1

uc1 <- c()

for(i in 0:8){
  
  val <- sum(fillAlt(prevct1, i)[,10])
  
  uc1 <- c(uc1, val)
  
}

kable(cbind(c(0:8),uc1), caption = "Ultimate claim amounts over observed years for branch 1", 
      col.names = c("Year","UCA"))

#Branch 2

uc2 <- c()

for(i in 0:8){
  
  val <- sum(fillAlt(prevct2, i)[,10])
  
  uc2 <- c(uc2, val)
  
}

kable(cbind(c(0:8),uc2), caption = "Ultimate claim amounts over observed years for branch 2", 
      col.names = c("Year","UCA"))

```

#Exercise 4

```{r echo = FALSE, warning = FALSE}

```


