---
title: "Project 2"
author: "Anton Stråhle"
date: "15 februari 2020"
output: pdf_document
---

#Exercise 1

```{r}

library(knitr)
library(readr)
library(tidyverse)

data <- read.delim("Projekt2_Grupp9.txt", sep = ";") %>% 
  mutate(ClaimYear = floor((ClaimDay-1)/365) + 1,
         PaymentYear = floor((PaymentDay-1)/365) + 1) %>% 
  rbind(c(1,1,1,0,1,10)) %>% 
  rbind(c(1,1,1,0,10,19)) #Added to deal with aggregation in a simple manner

ct <- data %>% #Trapezoid
  group_by(ClaimYear, PaymentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>% 
  mutate(DevelopmentYear = PaymentYear-ClaimYear + 1) %>% 
  select(-PaymentYear) %>% 
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  select(-ClaimYear)

```

Here we have the paid claims triangle for the last 10 yeras.

`r kable(ct %>% slice(11:20))`

```{r}

#Estimates the incremental factors f based on the observed trapezoid (or triangle!)
#off-set is used in ex4

estimateF <- function(ct, os = 0){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  fVec <- c()
  
  for(i in 1:(n-1)){
    
    f <- sum(ct[1:(r-i+os),i+1])/sum(ct[1:(r-i + os),i]) 
    
    fVec[i] <- f
    
  }
  
  fVec
  
}


fillct <- function(ct, s = 1, os = 0){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  fHat <- estimateF(ct, os)
  
  for(i in s:r){
  
    for(j in (n-i+s+os):n){
    
    ct[i,j] <- ct[i,j-1]*fHat[j-1]
    
    }
    
  }

  ct
  
}

options(knitr.kable.NA = '') #finare

fullct <- fillct(ct, 11)

fHat <- estimateF(ct)

kable(ct %>% slice(11:20), caption = "Paid claims triangle", row.names = c(1:10))

kable(fullct %>% slice(11:20), caption = "Full claims triangle predicted with CL", row.names = c(1:10))

kable(rowSums(fullct %>% slice(11:20)), caption = "Claim reserves", row.names = c(1:10), col.names = "Reserve")
```

#Exercise 2

We now want to check whether or not Mack's undrlying assumptions are met in our case. The assumptions are as follows.

\begin{enumerate}
  \item $E[C_{i,k+1}|C_{i,1},...,C{i,k}] = f_kC_{i,k}$
  \item Independent accident years
  \item $Var(C_{i,k+1}|C_{i,1},...,C{i,k}) = \sigma_k^2C_{i,k}$
\end{enumerate}

We begin by examing whether or not the we have an approximate linear relationship between $C_{i,k}$ and $C_{i,k+1}$ for $i = 1,...,10$

```{r}

#Gör om gör fint!

plot(ct$`1`, ct$`2`)
lines(seq(5e6,2e7, by = 10000), sapply(X = seq(5e6,2e7, by = 10000), FUN = function(x){ x*fHat[1]}), col = "blue")

plot(ct$`2`, ct$`3`)
lines(seq(1e7,4e7, by = 10000), sapply(X = seq(1e7,4e7, by = 10000), FUN = function(x){ x*fHat[2]}), col = "blue")

plot(ct$`3`, ct$`4`)
lines(seq(1e7,4e7, by = 10000), sapply(X = seq(1e7,4e7, by = 10000), FUN = function(x){ x*fHat[3]}), col = "blue")

plot(ct$`4`, ct$`5`)
lines(seq(1e7,5e7, by = 10000), sapply(X = seq(1e7,5e7, by = 10000), FUN = function(x){ x*fHat[4]}), col = "blue")

plot(ct$`5`, ct$`6`)
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[5]}), col = "blue")

plot(ct$`6`, ct$`7`)
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[6]}), col = "blue")

plot(ct$`7`, ct$`8`)
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[7]}), col = "blue")

plot(ct$`8`, ct$`9`)
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[8]}), col = "blue")

plot(ct$`9`, ct$`10`)
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[9]}), col = "blue")

plot(ct$`10`, ct$`11`)
lines(seq(1e7,6e7, by = 10000), sapply(X = seq(1e7,6e7, by = 10000), FUN = function(x){ x*fHat[10]}), col = "blue")

#Skoja dem blev faktiskt inte så fula

```

We note that the linear approximation seems to hold. We now want to plot the weighted residuals.

```{r}

residualHelper <- function(ct, s = 0){
  
  fHat <- estimateF(ct)
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  df <- data.frame(matrix(ncol = 3, nrow = 0))
  
  for(i in 1:(r-1)){
  
    for(j in 2:min(n-i+s-1, n)){
    
      res <- (ct[i,j] - ct[i,j-1]*fHat[j-1])/sqrt(ct[i,j-1])
      
      df <- rbind(df, unlist(c(i,unname(res), ct[i,j-1])))
    
    }
    
  }

  df
  
}

resFrame <- residualHelper(ct, 11) %>% 
  setNames(c("Year", "Res", "Ci"))

ggplot(resFrame, aes(x = Ci, y = Res)) +
  geom_point() +
  facet_wrap(~Year, scales = "free_y") 

#Notera att vi bara beaktar år med fler än 6 punkter enl Mack!
#OBS enbart använt vanliga f. Kan vara bra att kolla resterande

```

All years with more than 6 points, as suggested by Mack, seem to showcase random behaviour and no signs of any systematic deviations.

Lastly we want to examine whether or not we have any calender year effects. An example of a scenario where the assumption of independent years might be violated is if there is an overhaul of the way claims are handled.

```{r}

n <- ncol(ct)

r <- nrow(ct)

fList <- list()

for(k in 1:(n-1)){
  
  fk <- c()
  
  for(i in 1:(r-k)){
    
    temp <- unlist(ct[i, k+1])/unlist(ct[i,k])
    
    names(temp) <- k+i-1 #år
    
    fk <- c(fk, temp)
    
  }
  
  fList[[k]] <- sort(fk)
  
}

fList

#Detta blev ju väldigt fult men det får fram budskapet
#Gör en tabell där man räknar kardinaleteten av
#sFk och lFk för alla k


```

We might have some seasonal dependence idk??

#Exercise 3

From the paper by Mack we have that 

$$
Var(C_{i,I}) = C_{i,I}^2 \sum_{k=I+1-i}^{I-1} \frac{\sigma_k^2}{f_k^2}\left(\frac{1}{C_{i,k}} + \frac{1}{\sum_{j=1}^{I-k}C_{j,k}}\right)
$$
where we estimate $\sigma_k^2$ by

$$
\hat \sigma_k^2 = \frac{1}{I-k-1}\sum_{j=1}^{I-k}C_{j,k}\left(\frac{C_{j,k+1}}{C_{j,k}-\hat f_k}\right)^2
$$
which is an unbiased estimator. 

```{r}

#WE now need the last 11 years

ct11 <- data %>% 
  group_by(ClaimYear, PaymentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>% 
  mutate(DevelopmentYear = PaymentYear-ClaimYear + 1) %>% 
  select(-PaymentYear) %>% 
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  select(-ClaimYear)


estimateSigma <- function(ct, s){
  
  n <- ncol(ct)
  
  r <- nrow(ct)
  
  C <- fillct(ct, s)
  
  fHat <- estimateF(ct)
  
  sigmaHat <- c()
  
  for(k in 1:(n-2)){
    
    sum <- 0
    
    for(j in 1:min(r-k, n)){
      
      sum = sum + C[j,k]*(C[j,k+1]/(C[j,k]) - fHat[k])^2 
      
    }
    
    sigmaHat = c(sigmaHat, unlist(sum/(n-k-1)))
    
  }
  
  last <- min(sigmaHat[n-2]^4/sigmaHat[n-3], min(sigmaHat[n-2], sigmaHat[n-3]))
  
  names(last) <- n-1
  
  c(sigmaHat, last)
  
}

sigmaHat <- estimateSigma(ct11, 2) #estimates sigma^2

#add hoc from Mack

riskCalculation <- function(ct, s){
  
  n <- nrow(ct)
  
  C <- fillct(ct)
  
  fHat <- estimateF(ct)
  
  sigmaHat <- estimateSigma(ct11, s) #estimates sigma^2
  
  risks <- c()
  
  for(i in 2:n){
    
    sum <- 0
    
    for(k in (n+1-i):(n-1)){
      
      sum = sum + sigmaHat[k]/fHat[k]^2*(1/C[i,k] + 1/sum(C[1:(n-k),k])) 
      
    }
   
    risks <- c(risks, unlist(sum*C[i,n]^2))
     
  }
 
  risks
  
}

risks <- cbind(2:10,unname(riskCalculation(ct, ct11)), fullct[2:10,10]) %>% 
  data.frame() %>% 
  setNames(c("Year", "Reserve Risk", "Reserve")) 

kable(risks, caption = "Reserve risk for coming years")

```


```{r}

#Blankrader för att lösa aggregeringsproblems

data3 <- data %>% 
  filter(ClaimYear <= 10) %>% 
  rbind(c(1,1,1,0,1,10)) %>% 
  rbind(c(1,1,1,0,10,19))

#Not vi har skador med utvecklingsår 1+ vilket vi ej ska ha?? Behöver fråga.

ct <- data3 %>% 
  group_by(ClaimYear, PaymentYear) %>% 
  summarize(Total = sum(ClaimCost)) %>% 
  mutate(DevelopmentYear = PaymentYear-ClaimYear + 1) %>% 
  select(-PaymentYear) %>% 
  mutate(Total = cumsum(Total)) %>% 
  spread(value = Total, key = DevelopmentYear) %>% 
  ungroup() %>% 
  select(-ClaimYear)

estimateFAlt <- function(ct, known){
  
  n <- nrow(ct)
  
  fVec <- c()
  
  for(i in 1:(n-1)){
    
    f <- sum(ct[1:(n-i),i+1])/sum(ct[1:(n-i),i])
    
    fVec[i] <- f
    
  }
  
  fVec
  
}


fillAlt <- function(){
  
  
  
  
}


```




