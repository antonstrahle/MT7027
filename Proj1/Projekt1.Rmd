---
title: "MT7027: Project 1"
author: "Anton Stråhle, Jan Alexandersson & Max Sjödin"
output: pdf_document
---

#Introduction

In this project we are dealing with data concerning two different insurance branches collected over 10 years. We do not know anything about the sizes of the two insurance portfolios except the fact that their size has not changed over the decade which the data spans. Furthermore, the insurance products are of the non-life type and are paid out in lump payments. 

#Exercise 1

In this exercsie we want to find trends in the data for the two insurance branches in order to model future claims in a block-wise manner. Since the data is structured in a way such that we only have the claim day (i.e. $1,2,...,3650$) we assume that 365 day/year and that a month is 365/12 days (to get 12 months). 

```{r echo = FALSE, warning = FALSE}

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(knitr))

#standard theme
#theme_set(theme_gray())

### Use this to make it look like base R
theme_set(theme_bw())
theme_update(text = element_text(size=12),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_blank()
)

data <- read.delim2("Projekt1_Grupp9.txt", sep = ";")

type1Data <- data %>% filter(ClaimType == 1)

type2Data <- data %>% filter(ClaimType == 2)

```

```{r echo = FALSE, warning = FALSE}

data <- data %>% 
  mutate(Year = floor((.$ClaimDay-1)/(365)) + 1) %>% 
  mutate(ClaimDay = (ClaimDay-1) %% 365 + 1) %>% 
  mutate(Month = floor((.$ClaimDay-1)/(365/12)) + 1) 

#We can see seasonal effects
data %>% 
  ggplot(aes(Month)) +
  geom_bar() +
  scale_x_continuous(breaks=c(1:12)) +
  theme_classic() +
  facet_wrap(~ ClaimType, 
             labeller = labeller(ClaimType = c("1" = "Product 1", "2" = "Product 2"))) +
  ylab("Count")
```
From the previous histograms it seems reasonable to divide the months into two homogenous groups with their own claim processes. One group for months $(1-4, 9-12)$ and one for months $(5-8)$. We also wish to examine if we have homogeneity between the different years during which the claim data was collected.

```{r echo = FALSE, warning = FALSE}

#No effect over year for each claim type
data %>% 
  filter(ClaimType == 1) %>% 
  ggplot(aes(Month)) +
  geom_bar() +
  scale_x_continuous(breaks=c(1:12)) +
  theme_classic() +
  facet_wrap(~ Year, 
             labeller = labeller(ClaimType = c("1" = "Product 1", "2" = "Product 2"))) +
  ylab("Counts")

data %>% 
  filter(ClaimType == 2) %>% 
  ggplot(aes(Month)) +
  geom_bar() +
  scale_x_continuous(breaks=c(1:12)) +
  theme_classic() +
  facet_wrap(~ Year, 
             labeller = labeller(ClaimType = c("1" = "Type 1", "2" = "Type 2")))
  ylab("Counts")

  

```

```{r, include = FALSE}
library(fitdistrplus)
# ggplot(N11, aes(sample = n)) +
#   stat_qq(distribution = qpois, dparams = mean(N11$n)) +
#   stat_qq_line(distribution = qpois, dparams = mean(N11$n))

#Vi borde undersöka histogram, fördelningsfunktion och qqplot för antal skador. 
#Detta gör vi för varje säsong samt produkt
#Jämför med poisson samt negativ binomial (blandad poisson)

#Plots for N_11
N11 <- data %>% group_by(ClaimType, ClaimDay, Year, Month, Season) %>% 
  summarise(n = n()) %>% 
  filter(ClaimType ==1, Season == 1)

fit <- fitdistr(N11$n, "Negative Binomial")
df <- data.frame(x = c(N11$n, rpois(1000, mean(N11$n)), rnegbin(1000, mu = fit$estimate[2], theta = fit$estimate[1])), ggg = factor(rep(1:3, c(length(N11$n),1000,1000))))

df <- df[order(df$x), ]
df$ecdf <- ave(df$x, df$ggg, FUN=function(x) seq_along(x)/length(x))
plotcdfN11 <- ggplot(df, aes(x, ecdf, colour = ggg)) + geom_line() + scale_colour_hue(name="my legend", labels=c('Emp','Pois','NegBin'))



#Plots for N_12
N12 <- data %>% group_by(ClaimType, ClaimDay, Year, Month, Season) %>% 
  summarise(n = n()) %>% 
  filter(ClaimType ==1, Season == 2)

fit <- fitdistr(N12$n, "Negative Binomial")
df <- data.frame(x = c(N12$n, rpois(1000, mean(N12$n)), rnegbin(1000, mu = fit$estimate[2], theta = fit$estimate[1])), ggg = factor(rep(1:3, c(length(N12$n),1000,1000))))

df <- df[order(df$x), ]
df$ecdf <- ave(df$x, df$ggg, FUN=function(x) seq_along(x)/length(x))
plotcdfN12 <- ggplot(df, aes(x, ecdf, colour = ggg)) + geom_line() + scale_colour_hue(name="my legend", labels=c('Emp','Pois','NegBin'))



#Plots for N_21
N21 <- data %>% group_by(ClaimType, ClaimDay, Year, Month, Season) %>% 
  summarise(n = n()) %>% 
  filter(ClaimType ==2, Season == 1)

fit <- fitdistr(N21$n, "Negative Binomial")
df <- data.frame(x = c(N21$n, rpois(1000, mean(N21$n)), rnegbin(1000, mu = fit$estimate[2], theta = fit$estimate[1])), ggg = factor(rep(1:3, c(length(N21$n),1000,1000))))

df <- df[order(df$x), ]
df$ecdf <- ave(df$x, df$ggg, FUN=function(x) seq_along(x)/length(x))
plotcdfN21 <- ggplot(df, aes(x, ecdf, colour = ggg)) + geom_line() + scale_colour_hue(name="my legend", labels=c('Emp','Pois','NegBin'))



#Plots for N_22
N22 <- data %>% group_by(ClaimType, ClaimDay, Year, Month, Season) %>% 
  summarise(n = n()) %>% 
  filter(ClaimType == 2, Season == 2)

fit <- fitdistr(N22$n, "Negative Binomial")
df <- data.frame(x = c(N22$n, rpois(1000, mean(N22$n)), rnegbin(1000, mu = fit$estimate[2], theta = fit$estimate[1])), ggg = factor(rep(1:3, c(length(N22$n),1000,1000))))

df <- df[order(df$x), ]
df$ecdf <- ave(df$x, df$ggg, FUN=function(x) seq_along(x)/length(x))
plotcdfN22 <- ggplot(df, aes(x, ecdf, colour = ggg)) + geom_line() + scale_colour_hue(name="my legend", labels=c('Emp','Pois','NegBin'))

plotcdfN11
plotcdfN12
plotcdfN21
plotcdfN22
```

We note from the previous plots that there does not seem to be any major difference in the number of claims between the years.

We now wish to fit homogeneous Poisson distributions $N_ij$ (where $i$ represents the insurance type and $j$ represents the season) to the months of each season and each insurance product.

$$
N_{ij} \sim \text{Po}(\lambda_{ij})
$$

```{r echo = FALSE, warning = FALSE}

#Add season, 2=summer, 1=else
data <- data %>% mutate(Season = ifelse(Month %in% 5:8, 2, 1))
   
aggregatedData <- data %>% group_by(ClaimType, ClaimDay, Month, Year, Season) %>% 
  summarise(NumberOfClaims=n(), AggregatedCost = sum(ClaimCost))

#Distribution of NumberOfClaims and fitted poisson as points
estimatedLambda <- (aggregatedData %>% 
  group_by(ClaimType, Season) %>% 
  summarize(lambda = mean(NumberOfClaims)))$lambda

aggregatedData %>% 
  filter(ClaimType == 1) %>% 
  filter(Season == 1) %>% 
  ggplot() +
  geom_bar(aes(x=NumberOfClaims, y = (..count..)/sum(..count..))) +
  geom_line(data = data.frame(x=c(0:35)), aes(x=x, y=dpois(x, estimatedLambda[1]))) +
  xlab(expression(N[11])) +
  ylab("Density")

aggregatedData %>% 
  filter(ClaimType == 1) %>% 
  filter(Season == 2) %>% 
  ggplot() +
  geom_bar(aes(x=NumberOfClaims, y = (..count..)/sum(..count..))) +
  geom_line(data = data.frame(x=c(0:17)), aes(x=x, y=dpois(x, estimatedLambda[2]))) +
  xlab(expression(N[12])) +
  ylab("Density")

aggregatedData %>% 
  filter(ClaimType == 2) %>% 
  filter(Season == 1) %>% 
  ggplot() +
  geom_bar(aes(x=NumberOfClaims, y = (..count..)/sum(..count..))) +
  geom_line(data = data.frame(x=c(0:20)), aes(x=x, y=dpois(x, estimatedLambda[3]))) +
  xlab(expression(N[21])) +
  ylab("Density")

aggregatedData %>% 
  filter(ClaimType == 2) %>% 
  filter(Season == 2) %>% 
  ggplot() +
  geom_bar(aes(x=NumberOfClaims, y = (..count..)/sum(..count..))) +
  geom_line(data = data.frame(x=c(0:10)), aes(x=x, y=dpois(x, estimatedLambda[4]))) +
  xlab(expression(N[22])) +
  ylab("Density")
```

The Poisson variables which have been fit for the different seasons and insurance branches have had their parameter $\lambda_{ij}$ estimated through maximum-likelihood methods using the data from the 10 previous years. We note that we seem to have overdispersion for $N_{11}$ and $N_{12}$, meaning that the variance is not truly equal to the expectation which is the case for a Poisson variable. For $N_{21}$ and $N_{22}$ date does however seem to indicate that we have underdisperios, meaning that the variance is lower than the expectation. 

#Exercise 2

It is not only of interset to observe the number of claims over time but to also examine the sizes of these claims. 

```{r echo = FALSE ,warning = FALSE, message = FALSE}

data %>% 
  group_by(ClaimType, Month)  %>% 
  summarize(MeanClaim = mean(ClaimCost)) %>% 
  filter(ClaimType == 1) %>% 
  ggplot(aes(x = Month, y = MeanClaim)) +
    geom_point() +
    ylab("Mean Claim")

data %>% 
  group_by(ClaimType, Month)  %>% 
  summarize(MeanClaim = mean(ClaimCost)) %>% 
  filter(ClaimType == 2) %>% 
  ggplot(aes(x = Month, y = MeanClaim)) +
    geom_point() +
    ylab("Mean Claim")

```

It seems as if the avergae claim costs are time independent, atleast when aggregated on a monthly basis, from the two previous plots. We can also observe the mean of the claim sizes for every day in order to further strengthen the assumption of time independence.

```{r echo = FALSE ,warning = FALSE, message = FALSE}
#MeanClaim per day over time, ClaimType 1
data %>% 
  group_by(ClaimType, Year, ClaimDay)  %>% 
  summarize(MeanClaim = mean(ClaimCost)) %>% 
  filter(ClaimType == 1) %>% 
  ggplot(aes(x = ClaimDay, y = MeanClaim)) +
    geom_point() +
    ylab("Mean Claim") +
    ggtitle("Branch 1")
    

#MeanClaim per day over time, ClaimType 2
data %>% 
  group_by(ClaimType, Year, ClaimDay)  %>% 
  summarize(MeanClaim = mean(ClaimCost)) %>% 
  filter(ClaimType == 2) %>% 
  ggplot(aes(x = ClaimDay, y = MeanClaim)) +
    geom_point()  +
    ylab("Mean Claim")+
    ggtitle("Branch 2")

#MeanClaim per season for each ClaimTpe
# data %>% 
#   group_by(ClaimType, Season)  %>% 
#   summarize(MeanClaim = mean(ClaimCost)) %>% 
#   ggplot(aes(x = Season, y = MeanClaim, fill=ClaimType %>% as.factor())) +
#     scale_fill_discrete(name = "Claimtype") +
#     geom_col()
```

We note from the figures that the average claim sizes seem to be time independet. An interesting factor is however that all extremely deviating claim costs seem to occur during the summer (i.e period 2). In conclussion it seems as if the claim costs are independent of time. Another thing that we want to examine is whether or not we have independence between the average claim costs and the number of claims.

```{r echo = FALSE ,warning = FALSE, message = FALSE}

data %>% 
  group_by(Year, Month, ClaimType, Season) %>% 
  summarize(Counts = n(), Average = mean(ClaimCost)) %>% 
  ggplot(aes(x = Counts, y = Average)) +
    geom_point() +
    facet_wrap(~ClaimType+Season , scales = "free",
               labeller = label_wrap_gen(multi_line=FALSE)) +
    ggtitle("Insurance Product, Season")


```

We note that we do not seem to have any systematic correlation for any of the combinations of claims and claim costs, meaning that we can model the number of claims and the claim costs independently.

#Exercise 3 

```{r echo = FALSE, warning = FALSE, message = FALSE}

t1Counts <- type1Data %>% 
  group_by(ClaimDay) %>% 
  summarize(Counts = n())

t2Counts <- type2Data %>% 
  group_by(ClaimDay) %>% 
  summarize(Counts = n())

aggClaims <- inner_join(t1Counts, t2Counts, by = "ClaimDay") %>% 
  mutate(Year = floor((.$ClaimDay-1)/(365)) + 1) %>% 
  mutate(ClaimDay = (ClaimDay-1) %% 365 + 1) %>% 
  mutate(Month = floor((.$ClaimDay-1)/(365/12)) + 1) %>% 
  mutate(Season = ifelse(Month %in% 5:8, 2, 1))
  

ggplot(aggClaims, aes(x= Counts.x, y = Counts.y)) +
  geom_point() +
  facet_wrap(~Season, scales = "free")


#There does seem to be daily correlation in the number of claims which we obviously have to deal with in one way or another

```

We note from the figures above that there seems to be some kind of positive correlation between the two insurance products, meaning that we cannot model the claims for each product separatley, but that we instead have to model the jointly. We can however still model the claim costs of the two branches independently as we saw in the previous exercise.

#Exercise 4

As we mentioned previously the number of claims for the two branches are not independent, meaning that the have to be sampled from a bivariate distribution rather than two univariate distributions. This can be done by either deriving the bivariate distribution analytically and then sampling from it or, as we will do, by using a bootstrap sampler. We begin by sampling the number of claims for each month of the following year from the data of the correct season. 

```{r echo = FALSE, message = FALSE}

#Independent bootstrap samler

sampleD <- data %>% 
  group_by(Year, Month, Season) %>% 
  summarize(n1 = sum(ClaimType == 1), n2 = sum(ClaimType == 2)) 

s1 <- sampleD %>%
  data.frame() %>% 
  filter(Season == 1) %>% 
  sample_n(size = 8,replace = TRUE)

s2 <- sampleD %>%
  data.frame() %>% 
  filter(Season == 2) %>% 
  sample_n(size = 4,replace = TRUE)

claims <- rbind(s1[1:4,],s2, s1[5:8,]) %>% 
  select(n1, n2) 

costs <- data.frame(matrix(ncol = 2, nrow = 0)) 

#Ful loop IK men är trött och orkar ej googla

for(i in 1:nrow(claims)){
  
  TC1 = sum(sample(data[data$ClaimType == 1,]$ClaimCost, claims$n1[i], replace = TRUE))
  TC2 = sum(sample(data[data$ClaimType == 2,]$ClaimCost, claims$n2[i], replace = TRUE))
  
  costs <- rbind(costs, c(TC1, TC2)) %>% 
    setNames(c("c1", "c2"))
  
}

bsSample <- cbind(claims, costs) 

```

A single simulation gives us the following number of claims to the coming year.

```{r echo = FALSE, warning = FALSE, message = FALSE}

kable(claims)

```





